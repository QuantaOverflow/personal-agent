# Task ID: 11
# Title: Implement Intelligent Conversation History Management and Storage Optimization
# Status: pending
# Dependencies: 4, 8
# Priority: medium
# Description: Implement an intelligent conversation history management system with automatic summarization, tiered storage cleanup, and DO storage optimization to prevent unlimited growth as conversations increase.
# Details:
Implement comprehensive conversation history management system to optimize DO storage:

**1. Conversation Summarization Engine:**
```typescript
interface ConversationSummary {
  id: string;
  chatId: number;
  period: { start: Date; end: Date };
  keyTopics: string[];
  importantDecisions: string[];
  toolUsageHistory: ToolCall[];
  userPreferences: Record<string, any>;
  contextKeywords: string[];
  messageCount: number;
}

class ConversationSummarizer {
  async generateSummary(messages: AgentMessage[]): Promise<ConversationSummary> {
    const prompt = `Analyze this conversation and create a comprehensive summary including:
    1. Main discussion topics
    2. Important decisions made
    3. Tool usage patterns
    4. User preferences expressed
    5. Key context for future reference`;
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [{ role: "system", content: prompt }, ...messages],
      temperature: 0.3
    });
    
    return this.parseSummaryResponse(response);
  }
}
```

**2. Tiered Storage Management:**
```typescript
class ConversationStorageManager {
  private readonly RECENT_THRESHOLD = 20;
  private readonly MEDIUM_THRESHOLD = 100;
  private readonly STORAGE_LIMIT_MB = 50;
  
  async manageConversationStorage(chatId: number): Promise<void> {
    const messages = await this.getMessages(chatId);
    
    if (messages.length > this.MEDIUM_THRESHOLD) {
      await this.performTieredCleanup(chatId, messages);
    }
    
    await this.monitorStorageUsage(chatId);
  }
  
  private async performTieredCleanup(chatId: number, messages: AgentMessage[]) {
    // Keep recent 20 messages intact
    const recentMessages = messages.slice(-this.RECENT_THRESHOLD);
    
    // Summarize and compress medium-term messages (20-100)
    const mediumMessages = messages.slice(-this.MEDIUM_THRESHOLD, -this.RECENT_THRESHOLD);
    const compressedMedium = await this.compressMessages(mediumMessages);
    
    // Convert old messages to summary
    const oldMessages = messages.slice(0, -this.MEDIUM_THRESHOLD);
    const summary = await this.summarizer.generateSummary(oldMessages);
    
    await this.updateStoredConversation(chatId, {
      summary,
      compressedMedium,
      recentMessages
    });
  }
}
```

**3. Smart Cleanup Rules:**
```typescript
class MessageCleanupEngine {
  private readonly CLEANUP_RULES = {
    preserveToolCalls: true,
    preserveUserPreferences: true,
    removeGreetings: true,
    mergeSimilarQueries: true,
    removeEmptyResponses: true
  };
  
  async intelligentCleanup(messages: AgentMessage[]): Promise<AgentMessage[]> {
    let cleaned = messages;
    
    // Preserve all tool calls and results
    const toolMessages = cleaned.filter(m => m.toolCalls || m.toolResults);
    
    // Remove redundant greetings
    cleaned = this.removeRedundantGreetings(cleaned);
    
    // Merge similar queries
    cleaned = await this.mergeSimilarQueries(cleaned);
    
    // Ensure tool messages are preserved
    return this.mergePreservedMessages(cleaned, toolMessages);
  }
  
  private async mergeSimilarQueries(messages: AgentMessage[]): Promise<AgentMessage[]> {
    // Use embedding similarity to identify and merge similar queries
    const embeddings = await this.generateEmbeddings(messages);
    return this.performSimilarityMerging(messages, embeddings);
  }
}
```

**4. Storage Monitoring and Commands:**
```typescript
class StorageMonitor {
  async getStorageReport(chatId: number): Promise<StorageReport> {
    const usage = await this.calculateStorageUsage(chatId);
    return {
      totalMessages: usage.messageCount,
      storageUsedMB: usage.sizeInMB,
      summariesCount: usage.summaryCount,
      lastCleanup: usage.lastCleanupDate,
      recommendations: this.generateRecommendations(usage)
    };
  }
  
  async handleCleanupCommand(chatId: number, force: boolean = false): Promise<string> {
    const report = await this.getStorageReport(chatId);
    
    if (!force && report.storageUsedMB < this.STORAGE_LIMIT_MB) {
      return `Storage usage: ${report.storageUsedMB}MB. Cleanup not needed yet.`;
    }
    
    await this.performCleanup(chatId);
    return "Conversation history cleaned up successfully. Context preserved.";
  }
}
```

**5. Context Preservation System:**
```typescript
class ContextPreservationManager {
  async preserveContext(summary: ConversationSummary, recentMessages: AgentMessage[]): Promise<string> {
    const contextPrompt = `Based on this conversation summary and recent messages, 
    maintain continuity for future conversations. Key context to preserve:
    - User preferences: ${JSON.stringify(summary.userPreferences)}
    - Important decisions: ${summary.importantDecisions.join(', ')}
    - Tool usage patterns: ${summary.toolUsageHistory.map(t => t.name).join(', ')}`;
    
    return contextPrompt;
  }
  
  async restoreContext(chatId: number): Promise<AgentMessage[]> {
    const stored = await this.getStoredConversation(chatId);
    
    // Reconstruct conversation context from summary + recent messages
    const contextMessage: AgentMessage = {
      role: 'system',
      content: await this.preserveContext(stored.summary, stored.recentMessages)
    };
    
    return [contextMessage, ...stored.recentMessages];
  }
}
```

**6. Background Cleanup Scheduler:**
```typescript
// Add to scheduled handler
export async function handleScheduled(event: ScheduledEvent, env: Env): Promise<void> {
  const storageManager = new ConversationStorageManager(env);
  
  // Get all active chat IDs
  const activeChatIds = await storageManager.getActiveChatIds();
  
  for (const chatId of activeChatIds) {
    try {
      await storageManager.manageConversationStorage(chatId);
    } catch (error) {
      console.error(`Cleanup failed for chat ${chatId}:`, error);
    }
  }
}
```

**Configuration Options:**
- Configurable message thresholds
- Adjustable storage limits
- Customizable cleanup rules
- Backup retention policies
- Summary generation frequency

# Test Strategy:
**Comprehensive Testing Strategy:**

1. **Storage Growth Testing:**
   - Create test conversations with 150+ messages
   - Verify automatic summarization triggers at 100 messages
   - Confirm storage usage decreases after cleanup
   - Test with multiple concurrent chat sessions

2. **Summarization Quality Testing:**
   - Generate summaries for conversations with tool usage
   - Verify key information preservation (user preferences, decisions)
   - Test summary accuracy with different conversation types
   - Validate Chinese language summarization quality

3. **Tiered Storage Verification:**
   - Confirm recent 20 messages remain intact
   - Test medium-term message compression (20-100 range)
   - Verify old messages convert to summary format
   - Check storage space reduction metrics

4. **Context Preservation Testing:**
   - Test conversation continuity after cleanup
   - Verify user preferences persist through summarization
   - Confirm tool usage history is maintained
   - Test context restoration on conversation resume

5. **Cleanup Command Testing:**
   - Test manual `/cleanup` command functionality
   - Verify storage reports accuracy
   - Test force cleanup option
   - Confirm backup creation before cleanup

6. **Background Processing Testing:**
   - Test scheduled cleanup execution
   - Verify error handling for failed cleanups
   - Test cleanup performance with large datasets
   - Monitor DO storage usage over time

7. **Edge Case Testing:**
   - Test cleanup with tool-heavy conversations
   - Verify handling of corrupted message data
   - Test storage limit enforcement
   - Confirm graceful degradation under storage pressure

8. **Performance Testing:**
   - Measure cleanup execution time
   - Test concurrent cleanup operations
   - Verify memory usage during large cleanups
   - Test summarization API rate limiting
